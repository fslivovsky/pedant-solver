#ifndef PEDANT_MODELLOGGER_H_
#define PEDANT_MODELLOGGER_H_

#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <tuple>

#include "solvertypes.h"
#include "utils.h"

#include "buildAIGER.h"
#include "configuration.h"


#include "defaultvaluecontainer.h"


namespace pedant {

class ModelLogger {

 public:

    //circuits generated by the definition extractor
  using DefCircuit = std::vector<std::tuple<std::vector<int>,int>>;

  ModelLogger(const std::vector<int>& existential, const std::vector<int>& universal_variables, 
      const DefaultValueContainer& default_values, const Configuration& config);

  void init(int last_variable_in_matrix);

  /**
   * @param variable The forced variable.
   * @param forcing_clause The least element has to be the forced literal. 
   *    Will not be changed.
   **/
  void addForcingClause(const Clause& forcing_clause);

  void addDefinition(int variable, const std::vector<Clause>& definition, const DefCircuit& DefCircuit);
  /**
   * @param The condition shall only consist of arbiter variables
   **/
  void addConditionalDefinition(int variable, const std::vector<int>& condition, 
      const std::vector<Clause>& definition, const DefCircuit& DefCircuit);

  void writeModelAsCNFToFile(const std::string& file_name,const std::vector<int>& arbiter_assignment);
  /**
   * @param binary_AIGER If true write to a file in the aig format (binary aiger), else write to a file in aag (ascii aiger)
   **/
  void writeModelAsAIGToFile(const std::string& file_name,const std::vector<int>& arbiter_assignment, bool binary_AIGER);

 private:

  //The default clauses can always be computed from the container.
  //Thus there is no need to log them separately.
  const DefaultValueContainer& default_values;

  //indices of the existential variables in the subsequent vectors
  std::unordered_map<int,size_t> indices;

  // const std::vector<int>& existential_variables;
  std::vector<int> existential_variables;//we copy the variables in order to avoid problems with the reordering of variables
  const std::vector<int>& universal_variables;


  std::vector<std::vector<Clause>> positive_forcing_clauses;
  std::vector<std::vector<Clause>> negative_forcing_clauses;

  //The ith element in definitions_circuit corresponds to the ith element of definitions_cnf
  std::vector<DefCircuit> definitions_circuit;
  std::vector<std::vector<Clause>> definitions_cnf;

  //The ith elements of the subsequent vectors correspond to each other.
  std::vector<std::vector<std::vector<int>>> conditions;
  std::vector<std::vector<DefCircuit>> conditional_definitions_circuit;
  std::vector<std::vector<std::vector<Clause>>> conditional_definitions_cnf;


  //the entry consist of the condition the circuit and the clausal representation.
  std::vector<std::vector<std::tuple<std::vector<int>,DefCircuit,std::vector<Clause>>>> conditional_definitions;

  int max_variable_in_matrix;
  //a variable that does not occur in the matrix (but the variable may be used as an auxiliary variable at some place of the program)
  int unused_variable;

  //in order to avoid unnecessary large variables, auxiliary variables are renamed
  std::unordered_map<int,int> renaming_auxiliaries;

  const Configuration& config;

  bool writeClausalEncodingConditionalDefinitions(size_t variable_index,
      const std::vector<int>& arbiter_assignment, int& nof_clauses, std::ostream& out);

  void writeForcingClauses(const std::vector<Clause>& clauses, 
      const std::vector<int>& arbiter_assignment, std::vector<int>& active_clauses, 
      int& nof_clauses, std::ostream& out);

  void writeClausalEncodingDefaults(std::vector<Clause>& default_clauses, 
    int default_activator, int& nof_clauses, std::ostream& out);


  /**
   * @return A variable v such that -v<->clause
   **/
  int writeClauseActive(Clause& clause,int& nof_clauses, std::ostream& out);

  int writeClauseActive(Clause&& clause,int& nof_clauses, std::ostream& out);

  void processForcingClauses(size_t variable_index, const std::vector<int>& arbiter_assignment, 
      std::vector<Clause>& default_clauses, int& nof_clauses, std::ostream& out);


  void writeFormulaToStream(const std::vector<Clause>& formula, int& nof_clauses, std::ostream& out);
  void writeFormulaToStream(const std::vector<Clause>& formula,
      const std::vector<int>& arbiter_assignment, int& nof_clauses, std::ostream& out);

  void writeClauseToStream(const Clause& clause,std::ostream& out);
  /**
   * If the assignment satisfies the clause return false and do not write to the stream.
   * Otherwise apply the assignment to the clause, write the resulting clause to the stream and return true.
   **/
  bool writeClauseToStream(const Clause& clause, const std::vector<int>& assignment, std::ostream& out);

  void writeLiteral(int literal, std::ostream& out);

  size_t getIndex(int existential) const;

  /**
   * @param assignment must be sorted and for each literal in condition there must be a variable in assignment
   **/
  static bool isConditionEntailed(const std::vector<int>& condition,const std::vector<int>& assignment);

  /**
   * @param assignment must be sorted
   * @return true iff the clause is satisfied by the assignment
   **/
  static bool applyAssignment(Clause& clause, const std::vector<int>& assignment);

};

inline size_t ModelLogger::getIndex(int existential) const {
  return indices.at(existential);
}

inline bool ModelLogger::isConditionEntailed(const std::vector<int>& condition,const std::vector<int>& assignment) {
  for (int l:condition) {
    if (!std::binary_search(assignment.begin(),assignment.end(),l)) {
      return false;
    }
  }
  return true;
}

inline bool ModelLogger::applyAssignment(Clause& clause, const std::vector<int>& assignment) {
  auto it = clause.begin();
  while (it!=clause.end()) {
    if (std::binary_search(assignment.begin(),assignment.end(),*it)) {
      return true;
    } else if (std::binary_search(assignment.begin(),assignment.end(),-*it)) {
      it = clause.erase(it);
    } else {
      it++;
    }
  }
  return false;
}


}

#endif